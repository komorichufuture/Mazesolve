<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>è¿·è·¯ã‚²ãƒ¼ãƒ  - æ­©æ•°åˆ¶é™ï¼‹æ•µï¼‹ã‚¢ã‚¤ãƒ†ãƒ ï¼‹æ´—è„³</title>
<style>
  body{margin:0;display:grid;place-items:center;min-height:100vh;background:#f5f5f5;color:#111;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  .wrap{display:grid;gap:12px;justify-items:center;padding:20px}
  canvas{border:2px solid rgba(0,0,0,.3);border-radius:8px;touch-action:manipulation;background:#fff;box-shadow:0 4px 12px rgba(0,0,0,0.1)}
  .bar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center}
  button,input,select{font:inherit}
  button{padding:10px 16px;border:1px solid rgba(0,0,0,.25);background:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s}
  button:hover{background:#f0f0f0;transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  button.primary{background:#4CAF50;color:white;border-color:#4CAF50}
  button.primary:hover{background:#45a049}
  label{display:flex;gap:6px;align-items:center;border:1px solid rgba(0,0,0,.15);padding:6px 10px;border-radius:8px;background:#fff}
  input[type="number"]{width:70px;padding:4px}
  select{padding:6px 10px;border:1px solid rgba(0,0,0,.15);border-radius:8px;background:#fff}
  .status{display:flex;gap:16px;flex-wrap:wrap;align-items:center;justify-content:center;padding:12px;background:rgba(255,255,255,0.95);border-radius:8px;font-size:16px;font-weight:600;box-shadow:0 2px 8px rgba(0,0,0,0.1)}
  .status-item{display:flex;align-items:center;gap:6px}
  .status-label{color:#666;font-weight:400}
  .status-value{color:#111;font-weight:700}
  .game-over{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);color:#fff;padding:40px 60px;border-radius:16px;text-align:center;font-size:24px;z-index:1000;box-shadow:0 8px 32px rgba(0,0,0,0.5)}
  .game-over .rank{font-size:72px;font-weight:bold;margin:20px 0;text-shadow:0 0 20px rgba(255,255,255,0.5)}
  .game-over .rank.S{color:#FFD700}
  .game-over .rank.A{color:#C0C0C0}
  .game-over .rank.B{color:#CD7F32}
  .game-over button{margin-top:20px;font-size:18px;padding:12px 24px}
  .hint{font-size:14px;color:#666;text-align:center;margin-top:8px}
</style>
</head>
<body>
<div class="wrap">
  <div class="bar">
    <button id="gen" class="primary">æ–°ã—ã„ã‚²ãƒ¼ãƒ </button>
    <label>åˆ— <input id="cols" type="number" min="21" max="101" step="2" value="41"></label>
    <label>è¡Œ <input id="rows" type="number" min="21" max="101" step="2" value="31"></label>
    <label>é›£æ˜“åº¦ 
      <select id="difficulty">
        <option value="easy">ç°¡å˜</option>
        <option value="normal" selected>æ™®é€š</option>
        <option value="hard">é›£ã—ã„</option>
      </select>
    </label>
  </div>
  
  <div class="status">
    <div class="status-item">
      <span class="status-label">æ®‹ã‚Šæ­©æ•°:</span>
      <span class="status-value" id="stepsLeft">-</span>
    </div>
    <div class="status-item">
      <span class="status-label">é€æ˜åŒ–:</span>
      <span class="status-value" id="invisCount">-</span>
    </div>
    <div class="status-item">
      <span class="status-label">ãƒ¢ãƒ¼ãƒ‰:</span>
      <span class="status-value" id="enemyMode">-</span>
    </div>
    <div class="status-item">
      <span class="status-label">æ´—è„³æ•µ:</span>
      <span class="status-value" id="brainwashedCount">0</span>
    </div>
  </div>
  
  <canvas id="c" width="1000" height="700"></canvas>
  
  <div class="hint">
    çŸ¢å°ã‚­ãƒ¼ã¾ãŸã¯WASDã§ç§»å‹• | ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§é€æ˜åŒ–ä½¿ç”¨ | ğŸ’Šå›å¾©ã‚¢ã‚¤ãƒ†ãƒ  | ğŸ‘»é€æ˜åŒ–ã‚¢ã‚¤ãƒ†ãƒ <br>
    é€æ˜åŒ–ä¸­ã«æ•µã«å½“ãŸã‚‹ã¨æ´—è„³ï¼æ´—è„³ã•ã‚ŒãŸæ•µï¼ˆé’ï¼‰ã¯ä»–ã®æ•µã‚’æ”»æ’ƒã—ã¾ã™<br>
    ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ï¼šäººâ†’å¥³ï¼ˆé€æ˜åŒ–1å›ï¼‰â†’å¦–ï¼ˆé€æ˜åŒ–2å›ï¼‰ | æ•µï¼šå…µâ†’ç”·ï¼ˆæ´—è„³ï¼‰
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const DIRS = [
  {k:'N', dx:0, dy:-1, opp:'S'},
  {k:'E', dx:1, dy:0,  opp:'W'},
  {k:'S', dx:0, dy:1,  opp:'N'},
  {k:'W', dx:-1,dy:0,  opp:'E'},
];

const DIFFICULTY = {
  easy: {stepMult: 1.8, enemyCount: 4, scatterInterval: 8000, scatterDuration: 3000},
  normal: {stepMult: 1.4, enemyCount: 6, scatterInterval: 10000, scatterDuration: 2500},
  hard: {stepMult: 1.2, enemyCount: 9, scatterInterval: 12000, scatterDuration: 2000}
};

function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
function oddize(n){ n = Math.round(n); return (n%2===0)? n+1 : n; }
function randInt(n){ return Math.floor(Math.random()*n); }
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = randInt(i+1);
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function inBounds(x,y,cols,rows){ return x>=0 && y>=0 && x<cols && y<rows; }
function dist(x1,y1,x2,y2){ return Math.abs(x1-x2) + Math.abs(y1-y2); }

function makeGrid(cols, rows){
  return Array.from({length:rows}, (_,y)=>
    Array.from({length:cols}, (_,x)=>({
      x,y,
      v:false,
      w:{N:true,E:true,S:true,W:true}
    }))
  );
}

function carveMazeDFS(grid, cols, rows, sx, sy){
  const st = [];
  const start = grid[sy][sx];
  start.v = true;
  st.push(start);

  while(st.length){
    const cur = st[st.length-1];
    const dirs = shuffle(DIRS.slice());
    let carved = false;

    for(const d of dirs){
      const nx = cur.x + d.dx, ny = cur.y + d.dy;
      if(!inBounds(nx,ny,cols,rows)) continue;
      const nb = grid[ny][nx];
      if(nb.v) continue;

      cur.w[d.k] = false;
      nb.w[d.opp] = false;
      nb.v = true;
      st.push(nb);
      carved = true;
      break;
    }
    if(!carved) st.pop();
  }
}

function addLoops(grid, cols, rows, breaks){
  let tries = breaks * 4;
  while(breaks > 0 && tries-- > 0){
    const x = randInt(cols);
    const y = randInt(rows);
    const cell = grid[y][x];
    const d = DIRS[randInt(4)];
    const nx = x + d.dx, ny = y + d.dy;
    if(!inBounds(nx,ny,cols,rows)) continue;
    if(cell.w[d.k] === false) continue;

    cell.w[d.k] = false;
    grid[ny][nx].w[d.opp] = false;
    breaks--;
  }
}

function pickGoalsOnBoundary(cols, rows, count, startX, startY){
  const cand = [];
  for(let x=0;x<cols;x++){
    cand.push([x,0],[x,rows-1]);
  }
  for(let y=1;y<rows-1;y++){
    cand.push([0,y],[cols-1,y]);
  }
  const uniq = new Map();
  for(const [x,y] of cand){
    if(x===startX && y===startY) continue;
    uniq.set(`${x},${y}`,[x,y]);
  }
  const list = Array.from(uniq.values());
  shuffle(list);
  return list.slice(0, clamp(count,1,list.length));
}

function neighbors(grid, cols, rows, x, y){
  const c = grid[y][x];
  const out = [];
  for(const d of DIRS){
    const nx = x + d.dx, ny = y + d.dy;
    if(!inBounds(nx,ny,cols,rows)) continue;
    if(c.w[d.k] === false){
      out.push([nx,ny]);
    }
  }
  return out;
}

function bfsAllPrev(grid, cols, rows, sx, sy){
  const prev = Array.from({length:rows}, ()=>Array(cols).fill(null));
  const distMap = Array.from({length:rows}, ()=>Array(cols).fill(Infinity));
  const qx = new Int32Array(cols*rows);
  const qy = new Int32Array(cols*rows);
  let head=0, tail=0;

  distMap[sy][sx] = 0;
  qx[tail]=sx; qy[tail]=sy; tail++;

  while(head<tail){
    const x = qx[head], y = qy[head]; head++;
    const d0 = distMap[y][x];
    for(const [nx,ny] of neighbors(grid,cols,rows,x,y)){
      if(distMap[ny][nx] !== Infinity) continue;
      distMap[ny][nx] = d0 + 1;
      prev[ny][nx] = [x,y];
      qx[tail]=nx; qy[tail]=ny; tail++;
    }
  }
  return {prev, dist:distMap};
}

function reconstructPath(prev, sx, sy, gx, gy){
  if(prev[gy][gx] === null && !(sx===gx && sy===gy)) return null;
  const path = [];
  let x=gx, y=gy;
  path.push([x,y]);
  while(!(x===sx && y===sy)){
    const p = prev[y][x];
    if(!p) return null;
    x=p[0]; y=p[1];
    path.push([x,y]);
  }
  path.reverse();
  return path;
}

function placeItemsByDistance(distMap, cols, rows, minPct, maxPct, maxDist, count){
  const candidates = [];
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const d = distMap[y][x];
      if(d === Infinity || d === 0) continue;
      const pct = d / maxDist;
      if(pct >= minPct && pct <= maxPct){
        candidates.push([x,y]);
      }
    }
  }
  shuffle(candidates);
  return candidates.slice(0, Math.min(count, candidates.length));
}

function placeEnemiesOnGoalPaths(grid, cols, rows, start, goals, distMap, totalCount){
  const [sx, sy] = start;
  const allPathCells = new Set();
  const pathsByGoal = [];
  
  const {prev} = bfsAllPrev(grid, cols, rows, sx, sy);
  
  for(const [gx, gy] of goals){
    const path = reconstructPath(prev, sx, sy, gx, gy);
    if(!path) continue;
    
    const pathCells = [];
    for(let i=1; i<path.length-1; i++){
      const [px, py] = path[i];
      const key = `${px},${py}`;
      allPathCells.add(key);
      pathCells.push({x:px, y:py, dist: distMap[py][px]});
    }
    
    if(pathCells.length > 0){
      pathsByGoal.push({goal: [gx,gy], cells: pathCells});
    }
  }
  
  const selected = [];
  const used = new Set();
  
  const enemiesPerPath = Math.ceil(totalCount / pathsByGoal.length);
  
  for(const {cells} of pathsByGoal){
    cells.sort((a,b) => b.dist - a.dist);
    
    let placed = 0;
    for(const {x, y, dist: d} of cells){
      if(placed >= enemiesPerPath) break;
      if(selected.length >= totalCount) break;
      
      const key = `${x},${y}`;
      if(used.has(key)) continue;
      
      const maxPathDist = cells[0].dist;
      const pct = d / maxPathDist;
      if(pct < 0.3 || pct > 0.95) continue;
      
      let tooClose = false;
      for(const [ex, ey] of selected){
        if(dist(x, y, ex, ey) < 4){
          tooClose = true;
          break;
        }
      }
      if(tooClose) continue;
      
      selected.push([x, y]);
      used.add(key);
      placed++;
    }
  }
  
  if(selected.length < totalCount){
    const candidates = [];
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        const d = distMap[y][x];
        if(d === Infinity || d < 5) continue;
        const key = `${x},${y}`;
        if(used.has(key)) continue;
        candidates.push({x, y, dist: d});
      }
    }
    
    candidates.sort((a,b) => b.dist - a.dist);
    
    for(const {x, y} of candidates){
      if(selected.length >= totalCount) break;
      
      let tooClose = false;
      for(const [ex, ey] of selected){
        if(dist(x, y, ex, ey) < 4){
          tooClose = true;
          break;
        }
      }
      if(tooClose) continue;
      
      selected.push([x, y]);
      used.add(`${x},${y}`);
    }
  }
  
  return selected;
}

/* ===== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ===== */
let game = null;
let animFrame = null;

function initGame(){
  if(animFrame) cancelAnimationFrame(animFrame);
  
  let cols = oddize(parseInt(document.getElementById('cols').value,10));
  let rows = oddize(parseInt(document.getElementById('rows').value,10));
  cols = clamp(cols, 21, 101);
  rows = clamp(rows, 21, 101);
  
  const diffKey = document.getElementById('difficulty').value;
  const diff = DIFFICULTY[diffKey];
  
  const grid = makeGrid(cols, rows);
  const sx = Math.floor(cols/2);
  const sy = Math.floor(rows/2);
  
  carveMazeDFS(grid, cols, rows, sx, sy);
  addLoops(grid, cols, rows, Math.floor(cols * rows * 0.02));
  
  const goals = pickGoalsOnBoundary(cols, rows, 3, sx, sy);
  
  const {prev, dist:distMap} = bfsAllPrev(grid, cols, rows, sx, sy);
  
  let minDist = Infinity;
  for(const [gx,gy] of goals){
    const d = distMap[gy][gx];
    if(d < minDist) minDist = d;
  }
  
  const maxSteps = Math.ceil(minDist * diff.stepMult);
  
  const healItems = placeItemsByDistance(distMap, cols, rows, 0.60, 0.75, minDist, 2);
  const invisItems = placeItemsByDistance(distMap, cols, rows, 0.35, 0.45, minDist, 1)
    .concat(placeItemsByDistance(distMap, cols, rows, 0.45, 0.55, minDist, 1));
  
  const enemyPositions = placeEnemiesOnGoalPaths(grid, cols, rows, [sx, sy], goals, distMap, diff.enemyCount);
  const enemies = enemyPositions.map(([x,y])=>({
    x, y,
    scatterTarget: {x: randInt(cols), y: randInt(rows)},
    brainwashed: false, // æ´—è„³çŠ¶æ…‹
    huntingTarget: null // æ´—è„³æ™‚ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ•µ
  }));
  
  game = {
    grid, cols, rows,
    player: {x: sx, y: sy, invisUsedCount: 0},
    goals,
    enemies,
    healItems,
    invisItems,
    maxSteps,
    stepsLeft: maxSteps,
    invisRemaining: 2,
    totalInvisUsed: 0,
    invisActive: 0,
    gameOver: false,
    won: false,
    enemyMode: 'chase',
    modeTimer: 0,
    turnCount: 0,
    diff
  };
  
  updateStatus();
  draw();
}

function updateStatus(){
  if(!game) return;
  document.getElementById('stepsLeft').textContent = game.stepsLeft;
  document.getElementById('invisCount').textContent = `${game.invisRemaining}å› (${game.invisActive}æ­©)`;
  document.getElementById('enemyMode').textContent = game.enemyMode === 'chase' ? 'è¿½è·¡ä¸­' : 'æ•£é–‹ä¸­';
  
  const brainwashedCount = game.enemies.filter(e => e.brainwashed).length;
  document.getElementById('brainwashedCount').textContent = brainwashedCount;
}

function movePlayer(dx, dy){
  if(!game || game.gameOver) return;
  
  const {player, grid, cols, rows} = game;
  const cell = grid[player.y][player.x];
  
  let dirKey = null;
  if(dx===0 && dy===-1) dirKey = 'N';
  else if(dx===1 && dy===0) dirKey = 'E';
  else if(dx===0 && dy===1) dirKey = 'S';
  else if(dx===-1 && dy===0) dirKey = 'W';
  
  if(!dirKey || cell.w[dirKey]) return;
  
  const nx = player.x + dx;
  const ny = player.y + dy;
  if(!inBounds(nx,ny,cols,rows)) return;
  
  player.x = nx;
  player.y = ny;
  game.stepsLeft--;
  game.turnCount++;
  
  if(game.invisActive > 0) game.invisActive--;
  
  // æ•µã¨ã®è¡çªåˆ¤å®šï¼ˆé€æ˜åŒ–ä¸­ã¯æ´—è„³ï¼‰
  checkEnemyCollisions();
  
  // ã‚´ãƒ¼ãƒ«åˆ¤å®š
  for(const [gx,gy] of game.goals){
    if(player.x === gx && player.y === gy){
      game.won = true;
      game.gameOver = true;
      showGameOver();
      return;
    }
  }
  
  // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—
  for(let i=game.healItems.length-1; i>=0; i--){
    const [hx,hy] = game.healItems[i];
    if(player.x === hx && player.y === hy){
      game.stepsLeft += 20;
      game.healItems.splice(i,1);
    }
  }
  
  for(let i=game.invisItems.length-1; i>=0; i--){
    const [ix,iy] = game.invisItems[i];
    if(player.x === ix && player.y === iy){
      game.invisRemaining++;
      game.invisItems.splice(i,1);
    }
  }
  
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•å¾Œã€æ•µã‚’1ã‚¿ãƒ¼ãƒ³å‹•ã‹ã™
  moveEnemiesOneTurn();
  
  // æ­©æ•°åˆ‡ã‚Œåˆ¤å®š
  if(game.stepsLeft <= 0){
    game.gameOver = true;
    showGameOver();
    return;
  }
  
  updateStatus();
  draw();
}

function checkEnemyCollisions(){
  const {player, enemies, invisActive} = game;
  
  for(let i = enemies.length - 1; i >= 0; i--){
    const enemy = enemies[i];
    if(enemy.x === player.x && enemy.y === player.y){
      if(invisActive > 0){
        // é€æ˜åŒ–ä¸­ â†’ æ•µã‚’æ´—è„³
        enemy.brainwashed = true;
        enemy.huntingTarget = null; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¯moveEnemiesOneTurnã§è¨­å®š
      } else if(!enemy.brainwashed){
        // é€šå¸¸æ•µã«æ•ã¾ã£ãŸ
        game.gameOver = true;
        showGameOver();
        return;
      }
      // æ´—è„³æ¸ˆã¿æ•µã«ã¯å½“ãŸã£ã¦ã‚‚å•é¡Œãªã—
    }
  }
}

function moveEnemiesOneTurn(){
  if(!game || game.gameOver) return;
  
  const {player, enemies, grid, cols, rows, enemyMode, diff, turnCount} = game;
  
  // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆï¼ˆã‚¿ãƒ¼ãƒ³æ•°ãƒ™ãƒ¼ã‚¹ï¼‰
  const scatterTurnInterval = Math.floor(diff.scatterInterval / 500); // ãƒŸãƒªç§’â†’ã‚¿ãƒ¼ãƒ³å¤‰æ›
  const scatterTurnDuration = Math.floor(diff.scatterDuration / 500);
  
  if(enemyMode === 'chase' && turnCount % (scatterTurnInterval + scatterTurnDuration) >= scatterTurnInterval){
    if(game.enemyMode === 'chase'){
      game.enemyMode = 'scatter';
      enemies.forEach(e => {
        if(!e.brainwashed){
          e.scatterTarget = {x: randInt(cols), y: randInt(rows)};
        }
      });
    }
  } else {
    game.enemyMode = 'chase';
  }
  
  // å„æ•µã‚’1æ­©ç§»å‹•
  for(let i = enemies.length - 1; i >= 0; i--){
    const enemy = enemies[i];
    
    if(enemy.brainwashed){
      // æ´—è„³ã•ã‚ŒãŸæ•µï¼šä»–ã®é€šå¸¸æ•µã‚’è¿½è·¡
      if(!enemy.huntingTarget || enemy.huntingTarget.brainwashed){
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’æ¢ã™ï¼ˆé€šå¸¸æ•µã®ä¸­ã‹ã‚‰æœ€ã‚‚è¿‘ã„æ•µï¼‰
        let closestEnemy = null;
        let closestDist = Infinity;
        
        for(const otherEnemy of enemies){
          if(otherEnemy === enemy || otherEnemy.brainwashed) continue;
          const d = dist(enemy.x, enemy.y, otherEnemy.x, otherEnemy.y);
          if(d < closestDist){
            closestDist = d;
            closestEnemy = otherEnemy;
          }
        }
        
        enemy.huntingTarget = closestEnemy;
      }
      
      if(enemy.huntingTarget){
        const target = enemy.huntingTarget;
        const possibleMoves = neighbors(grid, cols, rows, enemy.x, enemy.y);
        
        if(possibleMoves.length > 0){
          // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«è¿‘ã¥ã
          let best = possibleMoves[0];
          let bestDist = dist(best[0], best[1], target.x, target.y);
          
          for(const [nx,ny] of possibleMoves){
            const d = dist(nx, ny, target.x, target.y);
            if(d < bestDist){
              bestDist = d;
              best = [nx,ny];
            }
          }
          
          enemy.x = best[0];
          enemy.y = best[1];
          
          // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã®è¡çªåˆ¤å®š
          if(enemy.x === target.x && enemy.y === target.y){
            // ä¸¡æ–¹æ¶ˆæ»…
            const targetIdx = enemies.indexOf(target);
            if(targetIdx !== -1) enemies.splice(targetIdx, 1);
            
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹èª¿æ•´
            const enemyIdx = enemies.indexOf(enemy);
            if(enemyIdx !== -1) enemies.splice(enemyIdx, 1);
            
            continue;
          }
        }
      }
    } else {
      // é€šå¸¸æ•µï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½è·¡ or æ•£é–‹
      const target = game.enemyMode === 'chase' 
        ? {x: player.x, y: player.y}
        : enemy.scatterTarget;
      
      const possibleMoves = neighbors(grid, cols, rows, enemy.x, enemy.y);
      if(possibleMoves.length === 0) continue;
      
      let best = possibleMoves[0];
      
      if(game.enemyMode === 'chase'){
        const {dist: playerDistMap} = bfsAllPrev(grid, cols, rows, target.x, target.y);
        let bestPathDist = playerDistMap[best[1]][best[0]];
        
        for(const [nx,ny] of possibleMoves){
          const pathDist = playerDistMap[ny][nx];
          if(pathDist < bestPathDist){
            bestPathDist = pathDist;
            best = [nx,ny];
          }
        }
      } else {
        let bestDist = dist(best[0], best[1], target.x, target.y);
        for(const [nx,ny] of possibleMoves){
          const d = dist(nx, ny, target.x, target.y);
          if(d < bestDist){
            bestDist = d;
            best = [nx,ny];
          }
        }
      }
      
      enemy.x = best[0];
      enemy.y = best[1];
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çªåˆ¤å®šï¼ˆé€æ˜åŒ–ä¸­ã§ãªã‘ã‚Œã°ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼‰
      if(game.invisActive === 0 && enemy.x === player.x && enemy.y === player.y){
        game.gameOver = true;
        showGameOver();
        return;
      }
    }
  }
  
  updateStatus();
}

function useInvisibility(){
  if(!game || game.gameOver) return;
  if(game.invisRemaining > 0 && game.invisActive === 0){
    game.invisRemaining--;
    game.invisActive = 10;
    game.totalInvisUsed++;
    updateStatus();
    draw();
  }
}

function showGameOver(){
  const modal = document.createElement('div');
  modal.className = 'game-over';
  
  if(game.won){
    const remaining = game.stepsLeft;
    const total = game.maxSteps;
    const ratio = remaining / total;
    
    let rank = 'B';
    if(ratio >= 0.3) rank = 'S';
    else if(ratio >= 0.15) rank = 'A';
    
    modal.innerHTML = `
      <div>ğŸ‰ ã‚¯ãƒªã‚¢! ğŸ‰</div>
      <div class="rank ${rank}">${rank}</div>
      <div>æ®‹ã‚Šæ­©æ•°: ${remaining} / ${total}</div>
      <button onclick="location.reload()">ã‚‚ã†ä¸€åº¦</button>
    `;
  } else {
    modal.innerHTML = `
      <div>ğŸ’€ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ ğŸ’€</div>
      <div>${game.stepsLeft <= 0 ? 'æ­©æ•°åˆ‡ã‚Œ' : 'æ•µã«æ•ã¾ã£ãŸ'}</div>
      <button onclick="location.reload()">ãƒªãƒˆãƒ©ã‚¤</button>
    `;
  }
  
  document.body.appendChild(modal);
}

/* ===== æç”» ===== */
function draw(){
  if(!game) return;
  
  ctx.clearRect(0,0,canvas.width,canvas.height);
  
  const {grid, cols, rows, player, goals, enemies, healItems, invisItems} = game;
  
  const pad = 20;
  const cellW = (canvas.width - pad*2) / cols;
  const cellH = (canvas.height - pad*2) / rows;
  const s = Math.min(cellW, cellH);
  const offX = (canvas.width  - cols*s)/2;
  const offY = (canvas.height - rows*s)/2;
  
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  
  // å£
  ctx.strokeStyle = '#333';
  ctx.lineWidth = Math.max(2, Math.floor(s*0.1));
  ctx.lineCap = 'square';
  
  ctx.beginPath();
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const c = grid[y][x];
      const x0 = offX + x*s;
      const y0 = offY + y*s;
      const x1 = x0 + s;
      const y1 = y0 + s;
      
      if(c.w.N){ ctx.moveTo(x0,y0); ctx.lineTo(x1,y0); }
      if(c.w.E){ ctx.moveTo(x1,y0); ctx.lineTo(x1,y1); }
      if(c.w.S){ ctx.moveTo(x0,y1); ctx.lineTo(x1,y1); }
      if(c.w.W){ ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); }
    }
  }
  ctx.stroke();
  
  // ã‚´ãƒ¼ãƒ«
  for(const [gx,gy] of goals){
    const cx = offX + (gx+0.5)*s;
    const cy = offY + (gy+0.5)*s;
    const r = s*0.35;
    
    ctx.fillStyle = '#4CAF50';
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.floor(s*0.4)}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('G', cx, cy);
  }
  
  // å›å¾©ã‚¢ã‚¤ãƒ†ãƒ 
  for(const [hx,hy] of healItems){
    const cx = offX + (hx+0.5)*s;
    const cy = offY + (hy+0.5)*s;
    ctx.font = `${Math.floor(s*0.6)}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ğŸ’Š', cx, cy);
  }
  
  // é€æ˜åŒ–ã‚¢ã‚¤ãƒ†ãƒ 
  for(const [ix,iy] of invisItems){
    const cx = offX + (ix+0.5)*s;
    const cy = offY + (iy+0.5)*s;
    ctx.font = `${Math.floor(s*0.6)}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ğŸ‘»', cx, cy);
  }
  
  // æ•µ
  for(const enemy of enemies){
    const cx = offX + (enemy.x+0.5)*s;
    const cy = offY + (enemy.y+0.5)*s;
    const r = s*0.32;
    
    if(enemy.brainwashed){
      // æ´—è„³ã•ã‚ŒãŸæ•µã¯é’è‰²
      ctx.fillStyle = '#2196F3';
    } else {
      ctx.fillStyle = game.enemyMode === 'chase' ? '#f44336' : '#FF9800';
    }
    
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
    
    // æ•µã®æ–‡å­—è¡¨ç¤º
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.floor(s*0.5)}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    let enemyChar = 'å…µ';
    if(enemy.brainwashed && game.invisActive > 0){
      enemyChar = 'ç”·';
    } else if(enemy.brainwashed){
      enemyChar = 'å…µ'; // æ´—è„³æ¸ˆã¿ã ãŒé€æ˜åŒ–åˆ‡ã‚Œ
    }
    
    ctx.fillText(enemyChar, cx, cy);
  }
  
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
  const px = offX + (player.x+0.5)*s;
  const py = offY + (player.y+0.5)*s;
  const pr = s*0.35;
  
  if(game.invisActive > 0){
    ctx.globalAlpha = 0.4;
  }
  
  ctx.fillStyle = '#2196F3';
  ctx.beginPath();
  ctx.arc(px,py,pr,0,Math.PI*2);
  ctx.fill();
  
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.floor(s*0.5)}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ–‡å­—ã‚’é€æ˜åŒ–ä½¿ç”¨å›æ•°ã§å¤‰æ›´
  let playerChar = 'äºº';
  if(game.totalInvisUsed >= 2){
    playerChar = 'å¦–';
  } else if(game.invisActive > 0){
    playerChar = 'å¥³';
  }
  
  ctx.fillText(playerChar, px, py);
}

/* ===== ã‚¤ãƒ™ãƒ³ãƒˆ ===== */
document.getElementById('gen').addEventListener('click', initGame);

document.addEventListener('keydown', e => {
  if(!game || game.gameOver) return;
  
  const key = e.key.toLowerCase();
  
  if(key === 'arrowup' || key === 'w'){
    e.preventDefault();
    movePlayer(0,-1);
  } else if(key === 'arrowdown' || key === 's'){
    e.preventDefault();
    movePlayer(0,1);
  } else if(key === 'arrowleft' || key === 'a'){
    e.preventDefault();
    movePlayer(-1,0);
  } else if(key === 'arrowright' || key === 'd'){
    e.preventDefault();
    movePlayer(1,0);
  } else if(key === ' '){
    e.preventDefault();
    useInvisibility();
  }
});

// åˆæœŸç”Ÿæˆ
initGame();
</script>
</body>
</html>
