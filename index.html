<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>è¿·è·¯ã‚²ãƒ¼ãƒ  - ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œç‰ˆ</title>
<style>
  * {margin:0;padding:0;box-sizing:border-box;}
  body{
    width:100vw;
    height:100vh;
    overflow:hidden;
    background:#f5f5f5;
    color:#111;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    display:flex;
    flex-direction:column;
  }
  
  .top-bar{
    background:rgba(255,255,255,0.95);
    padding:8px;
    box-shadow:0 2px 8px rgba(0,0,0,0.1);
    z-index:100;
  }
  
  .controls{
    display:flex;
    gap:6px;
    flex-wrap:wrap;
    align-items:center;
    justify-content:center;
    margin-bottom:6px;
  }
  
  button,input,select{font:inherit;font-size:12px;}
  button{
    padding:6px 12px;
    border:1px solid rgba(0,0,0,.25);
    background:#fff;
    border-radius:6px;
    cursor:pointer;
    transition:all 0.2s;
  }
  button:active{background:#e0e0e0;transform:scale(0.95);}
  button.primary{background:#4CAF50;color:white;border-color:#4CAF50;}
  
  label{
    display:flex;
    gap:4px;
    align-items:center;
    font-size:11px;
  }
  input[type="number"]{width:50px;padding:3px;font-size:11px;}
  select{padding:4px 8px;border:1px solid rgba(0,0,0,.15);border-radius:6px;background:#fff;}
  
  .status{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
    justify-content:center;
    font-size:12px;
    font-weight:600;
  }
  .status-item{display:flex;align-items:center;gap:4px;}
  .status-label{color:#666;font-weight:400;}
  .status-value{color:#111;font-weight:700;}
  
  .game-container{
    flex:1;
    position:relative;
    overflow:hidden;
    background:#fff;
    touch-action:none;
  }
  
  canvas{
    display:block;
    width:100%;
    height:100%;
    touch-action:none;
  }
  
  .mobile-controls{
    position:absolute;
    top:20px;
    left:0;
    right:0;
    display:flex;
    justify-content:space-between;
    padding:0 20px;
    pointer-events:none;
    z-index:50;
  }
  
  .dpad{
    position:relative;
    width:140px;
    height:140px;
    pointer-events:all;
    opacity:0.85;
  }
  
  .dpad-btn{
    position:absolute;
    width:50px;
    height:50px;
    background:rgba(255,255,255,0.9);
    border:2px solid rgba(0,0,0,0.3);
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:24px;
    font-weight:bold;
    color:#333;
    user-select:none;
    box-shadow:0 3px 10px rgba(0,0,0,0.3);
    backdrop-filter:blur(5px);
  }
  
  .dpad-btn:active{
    background:rgba(200,200,200,0.95);
    transform:scale(0.95);
  }
  
  .dpad-up{top:0;left:45px;}
  .dpad-down{bottom:0;left:45px;}
  .dpad-left{top:45px;left:0;}
  .dpad-right{top:45px;right:0;}
  
  .action-btns{
    display:flex;
    flex-direction:column;
    gap:10px;
    pointer-events:all;
  }
  
  .invis-btn{
    width:70px;
    height:70px;
    background:rgba(139,69,255,0.92);
    border:3px solid rgba(255,255,255,0.9);
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:32px;
    box-shadow:0 4px 12px rgba(0,0,0,0.4);
    user-select:none;
    backdrop-filter:blur(5px);
  }
  
  .invis-btn:active{
    background:rgba(100,50,200,0.95);
    transform:scale(0.95);
  }
  
  .game-over{
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    background:rgba(0,0,0,0.95);
    color:#fff;
    padding:30px 40px;
    border-radius:16px;
    text-align:center;
    font-size:20px;
    z-index:1000;
    box-shadow:0 8px 32px rgba(0,0,0,0.5);
    max-width:90vw;
  }
  .game-over .rank{
    font-size:60px;
    font-weight:bold;
    margin:15px 0;
    text-shadow:0 0 20px rgba(255,255,255,0.5);
  }
  .game-over .rank.S{color:#FFD700;}
  .game-over .rank.A{color:#C0C0C0;}
  .game-over .rank.B{color:#CD7F32;}
  .game-over button{margin-top:15px;font-size:16px;padding:10px 20px;}
  
  @media (max-width: 600px) {
    .controls{font-size:11px;}
    .status{font-size:11px;}
  }
</style>
</head>
<body>

<div class="top-bar">
  <div class="controls">
    <button id="gen" class="primary">æ–°ã‚²ãƒ¼ãƒ </button>
    <label>åˆ— <input id="cols" type="number" min="15" max="51" step="2" value="21"></label>
    <label>è¡Œ <input id="rows" type="number" min="25" max="71" step="2" value="41"></label>
    <label>é›£æ˜“åº¦ 
      <select id="difficulty">
        <option value="easy">ç°¡å˜</option>
        <option value="normal" selected>æ™®é€š</option>
        <option value="hard">é›£ã—ã„</option>
      </select>
    </label>
  </div>
  
  <div class="status">
    <div class="status-item">
      <span class="status-label">æ­©æ•°:</span>
      <span class="status-value" id="stepsLeft">-</span>
    </div>
    <div class="status-item">
      <span class="status-label">é€æ˜:</span>
      <span class="status-value" id="invisCount">-</span>
    </div>
    <div class="status-item">
      <span class="status-label">ãƒ¢ãƒ¼ãƒ‰:</span>
      <span class="status-value" id="enemyMode">-</span>
    </div>
    <div class="status-item">
      <span class="status-label">æ´—è„³:</span>
      <span class="status-value" id="brainwashedCount">0</span>
    </div>
  </div>
</div>

<div class="game-container">
  <canvas id="c"></canvas>
  
  <div class="mobile-controls">
    <div class="dpad">
      <div class="dpad-btn dpad-up" data-dir="up">â†‘</div>
      <div class="dpad-btn dpad-down" data-dir="down">â†“</div>
      <div class="dpad-btn dpad-left" data-dir="left">â†</div>
      <div class="dpad-btn dpad-right" data-dir="right">â†’</div>
    </div>
    
    <div class="action-btns">
      <div class="invis-btn" id="invisBtn">ğŸ‘»</div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«åˆã‚ã›ã‚‹
function resizeCanvas(){
  const container = document.querySelector('.game-container');
  const dpr = window.devicePixelRatio || 1;
  canvas.width = container.clientWidth * dpr;
  canvas.height = container.clientHeight * dpr;
  canvas.style.width = container.clientWidth + 'px';
  canvas.style.height = container.clientHeight + 'px';
  ctx.scale(dpr, dpr);
  if(game) draw();
}
window.addEventListener('resize', resizeCanvas);
// åˆæœŸåŒ–ã‚’é…å»¶å®Ÿè¡Œ
setTimeout(resizeCanvas, 100);

// ã‚¹ãƒãƒ›ãƒ–ãƒ©ã‚¦ã‚¶ã®URLãƒãƒ¼ã‚’éš ã™ãŸã‚ã®å‡¦ç†
function hideAddressBar(){
  setTimeout(() => {
    window.scrollTo(0, 1);
    setTimeout(() => window.scrollTo(0, 0), 0);
  }, 100);
}

// ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã¨ãƒªã‚µã‚¤ã‚ºæ™‚ã«URLãƒãƒ¼ã‚’éš ã™
window.addEventListener('load', hideAddressBar);
window.addEventListener('orientationchange', hideAddressBar);

// ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ã‚‚URLãƒãƒ¼ã‚’éš ã™
document.addEventListener('touchstart', function onFirstTouch() {
  hideAddressBar();
  document.removeEventListener('touchstart', onFirstTouch);
}, {passive: true});

const DIRS = [
  {k:'N', dx:0, dy:-1, opp:'S'},
  {k:'E', dx:1, dy:0,  opp:'W'},
  {k:'S', dx:0, dy:1,  opp:'N'},
  {k:'W', dx:-1,dy:0,  opp:'E'},
];

const DIFFICULTY = {
  easy: {stepMult: 1.8, enemyCount: 3, scatterInterval: 8000, scatterDuration: 3000},
  normal: {stepMult: 1.4, enemyCount: 5, scatterInterval: 10000, scatterDuration: 2500},
  hard: {stepMult: 1.2, enemyCount: 7, scatterInterval: 12000, scatterDuration: 2000}
};

function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
function oddize(n){ n = Math.round(n); return (n%2===0)? n+1 : n; }
function randInt(n){ return Math.floor(Math.random()*n); }
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = randInt(i+1);
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function inBounds(x,y,cols,rows){ return x>=0 && y>=0 && x<cols && y<rows; }
function dist(x1,y1,x2,y2){ return Math.abs(x1-x2) + Math.abs(y1-y2); }

function makeGrid(cols, rows){
  return Array.from({length:rows}, (_,y)=>
    Array.from({length:cols}, (_,x)=>({
      x,y,
      v:false,
      w:{N:true,E:true,S:true,W:true}
    }))
  );
}

function carveMazeDFS(grid, cols, rows, sx, sy){
  const st = [];
  const start = grid[sy][sx];
  start.v = true;
  st.push(start);

  while(st.length){
    const cur = st[st.length-1];
    const dirs = shuffle(DIRS.slice());
    let carved = false;

    for(const d of dirs){
      const nx = cur.x + d.dx, ny = cur.y + d.dy;
      if(!inBounds(nx,ny,cols,rows)) continue;
      const nb = grid[ny][nx];
      if(nb.v) continue;

      cur.w[d.k] = false;
      nb.w[d.opp] = false;
      nb.v = true;
      st.push(nb);
      carved = true;
      break;
    }
    if(!carved) st.pop();
  }
}

function addLoops(grid, cols, rows, breaks){
  let tries = breaks * 4;
  while(breaks > 0 && tries-- > 0){
    const x = randInt(cols);
    const y = randInt(rows);
    const cell = grid[y][x];
    const d = DIRS[randInt(4)];
    const nx = x + d.dx, ny = y + d.dy;
    if(!inBounds(nx,ny,cols,rows)) continue;
    if(cell.w[d.k] === false) continue;

    cell.w[d.k] = false;
    grid[ny][nx].w[d.opp] = false;
    breaks--;
  }
}

function pickGoalsOnBoundary(cols, rows, count, startX, startY){
  const cand = [];
  for(let x=0;x<cols;x++){
    cand.push([x,0],[x,rows-1]);
  }
  for(let y=1;y<rows-1;y++){
    cand.push([0,y],[cols-1,y]);
  }
  const uniq = new Map();
  for(const [x,y] of cand){
    if(x===startX && y===startY) continue;
    uniq.set(`${x},${y}`,[x,y]);
  }
  const list = Array.from(uniq.values());
  shuffle(list);
  return list.slice(0, clamp(count,1,list.length));
}

function neighbors(grid, cols, rows, x, y){
  const c = grid[y][x];
  const out = [];
  for(const d of DIRS){
    const nx = x + d.dx, ny = y + d.dy;
    if(!inBounds(nx,ny,cols,rows)) continue;
    if(c.w[d.k] === false){
      out.push([nx,ny]);
    }
  }
  return out;
}

function bfsAllPrev(grid, cols, rows, sx, sy){
  const prev = Array.from({length:rows}, ()=>Array(cols).fill(null));
  const distMap = Array.from({length:rows}, ()=>Array(cols).fill(Infinity));
  const qx = new Int32Array(cols*rows);
  const qy = new Int32Array(cols*rows);
  let head=0, tail=0;

  distMap[sy][sx] = 0;
  qx[tail]=sx; qy[tail]=sy; tail++;

  while(head<tail){
    const x = qx[head], y = qy[head]; head++;
    const d0 = distMap[y][x];
    for(const [nx,ny] of neighbors(grid,cols,rows,x,y)){
      if(distMap[ny][nx] !== Infinity) continue;
      distMap[ny][nx] = d0 + 1;
      prev[ny][nx] = [x,y];
      qx[tail]=nx; qy[tail]=ny; tail++;
    }
  }
  return {prev, dist:distMap};
}

function reconstructPath(prev, sx, sy, gx, gy){
  if(prev[gy][gx] === null && !(sx===gx && sy===gy)) return null;
  const path = [];
  let x=gx, y=gy;
  path.push([x,y]);
  while(!(x===sx && y===sy)){
    const p = prev[y][x];
    if(!p) return null;
    x=p[0]; y=p[1];
    path.push([x,y]);
  }
  path.reverse();
  return path;
}

function placeItemsByDistance(distMap, cols, rows, minPct, maxPct, maxDist, count){
  const candidates = [];
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const d = distMap[y][x];
      if(d === Infinity || d === 0) continue;
      const pct = d / maxDist;
      if(pct >= minPct && pct <= maxPct){
        candidates.push([x,y]);
      }
    }
  }
  shuffle(candidates);
  return candidates.slice(0, Math.min(count, candidates.length));
}

function placeEnemiesOnGoalPaths(grid, cols, rows, start, goals, distMap, totalCount){
  const [sx, sy] = start;
  const pathsByGoal = [];
  
  const {prev} = bfsAllPrev(grid, cols, rows, sx, sy);
  
  for(const [gx, gy] of goals){
    const path = reconstructPath(prev, sx, sy, gx, gy);
    if(!path) continue;
    
    const pathCells = [];
    for(let i=1; i<path.length-1; i++){
      const [px, py] = path[i];
      pathCells.push({x:px, y:py, dist: distMap[py][px]});
    }
    
    if(pathCells.length > 0){
      pathsByGoal.push({goal: [gx,gy], cells: pathCells});
    }
  }
  
  const selected = [];
  const used = new Set();
  
  const enemiesPerPath = Math.ceil(totalCount / pathsByGoal.length);
  
  for(const {cells} of pathsByGoal){
    cells.sort((a,b) => b.dist - a.dist);
    
    let placed = 0;
    for(const {x, y, dist: d} of cells){
      if(placed >= enemiesPerPath) break;
      if(selected.length >= totalCount) break;
      
      const key = `${x},${y}`;
      if(used.has(key)) continue;
      
      const maxPathDist = cells[0].dist;
      const pct = d / maxPathDist;
      if(pct < 0.3 || pct > 0.95) continue;
      
      let tooClose = false;
      for(const [ex, ey] of selected){
        if(dist(x, y, ex, ey) < 4){
          tooClose = true;
          break;
        }
      }
      if(tooClose) continue;
      
      selected.push([x, y]);
      used.add(key);
      placed++;
    }
  }
  
  if(selected.length < totalCount){
    const candidates = [];
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        const d = distMap[y][x];
        if(d === Infinity || d < 5) continue;
        const key = `${x},${y}`;
        if(used.has(key)) continue;
        candidates.push({x, y, dist: d});
      }
    }
    
    candidates.sort((a,b) => b.dist - a.dist);
    
    for(const {x, y} of candidates){
      if(selected.length >= totalCount) break;
      
      let tooClose = false;
      for(const [ex, ey] of selected){
        if(dist(x, y, ex, ey) < 4){
          tooClose = true;
          break;
        }
      }
      if(tooClose) continue;
      
      selected.push([x, y]);
    }
  }
  
  return selected;
}

let game = null;

function initGame(){
  let cols = oddize(parseInt(document.getElementById('cols').value,10));
  let rows = oddize(parseInt(document.getElementById('rows').value,10));
  cols = clamp(cols, 15, 51);
  rows = clamp(rows, 25, 71);
  
  const diffKey = document.getElementById('difficulty').value;
  const diff = DIFFICULTY[diffKey];
  
  const grid = makeGrid(cols, rows);
  const sx = Math.floor(cols/2);
  const sy = Math.floor(rows/2);
  
  carveMazeDFS(grid, cols, rows, sx, sy);
  addLoops(grid, cols, rows, Math.floor(cols * rows * 0.02));
  
  const goals = pickGoalsOnBoundary(cols, rows, 3, sx, sy);
  
  const {prev, dist:distMap} = bfsAllPrev(grid, cols, rows, sx, sy);
  
  let minDist = Infinity;
  for(const [gx,gy] of goals){
    const d = distMap[gy][gx];
    if(d < minDist) minDist = d;
  }
  
  const maxSteps = Math.ceil(minDist * diff.stepMult);
  
  const healItems = placeItemsByDistance(distMap, cols, rows, 0.60, 0.75, minDist, 2);
  const invisItems = placeItemsByDistance(distMap, cols, rows, 0.35, 0.45, minDist, 1)
    .concat(placeItemsByDistance(distMap, cols, rows, 0.45, 0.55, minDist, 1));
  
  const enemyPositions = placeEnemiesOnGoalPaths(grid, cols, rows, [sx, sy], goals, distMap, diff.enemyCount);
  const enemies = enemyPositions.map(([x,y])=>({
    x, y,
    scatterTarget: {x: randInt(cols), y: randInt(rows)},
    brainwashed: false,
    huntingTarget: null
  }));
  
  game = {
    grid, cols, rows,
    player: {x: sx, y: sy, invisUsedCount: 0},
    goals,
    enemies,
    healItems,
    invisItems,
    maxSteps,
    stepsLeft: maxSteps,
    invisRemaining: 2,
    totalInvisUsed: 0,
    invisActive: 0,
    gameOver: false,
    won: false,
    enemyMode: 'chase',
    turnCount: 0,
    diff
  };
  
  updateStatus();
  draw();
}

function updateStatus(){
  if(!game) return;
  document.getElementById('stepsLeft').textContent = game.stepsLeft;
  document.getElementById('invisCount').textContent = `${game.invisRemaining}å›(${game.invisActive})`;
  document.getElementById('enemyMode').textContent = game.enemyMode === 'chase' ? 'è¿½è·¡' : 'æ•£é–‹';
  
  const brainwashedCount = game.enemies.filter(e => e.brainwashed).length;
  document.getElementById('brainwashedCount').textContent = brainwashedCount;
}

function movePlayer(dx, dy){
  if(!game || game.gameOver) return;
  
  const {player, grid, cols, rows} = game;
  const cell = grid[player.y][player.x];
  
  let dirKey = null;
  if(dx===0 && dy===-1) dirKey = 'N';
  else if(dx===1 && dy===0) dirKey = 'E';
  else if(dx===0 && dy===1) dirKey = 'S';
  else if(dx===-1 && dy===0) dirKey = 'W';
  
  if(!dirKey || cell.w[dirKey]) return;
  
  const nx = player.x + dx;
  const ny = player.y + dy;
  if(!inBounds(nx,ny,cols,rows)) return;
  
  player.x = nx;
  player.y = ny;
  game.stepsLeft--;
  game.turnCount++;
  
  if(game.invisActive > 0) game.invisActive--;
  
  checkEnemyCollisions();
  
  for(const [gx,gy] of game.goals){
    if(player.x === gx && player.y === gy){
      game.won = true;
      game.gameOver = true;
      showGameOver();
      return;
    }
  }
  
  for(let i=game.healItems.length-1; i>=0; i--){
    const [hx,hy] = game.healItems[i];
    if(player.x === hx && player.y === hy){
      game.stepsLeft += 20;
      game.healItems.splice(i,1);
    }
  }
  
  for(let i=game.invisItems.length-1; i>=0; i--){
    const [ix,iy] = game.invisItems[i];
    if(player.x === ix && player.y === iy){
      game.invisRemaining++;
      game.invisItems.splice(i,1);
    }
  }
  
  moveEnemiesOneTurn();
  
  if(game.stepsLeft <= 0){
    game.gameOver = true;
    showGameOver();
    return;
  }
  
  updateStatus();
  draw();
}

function checkEnemyCollisions(){
  const {player, enemies, invisActive} = game;
  
  for(let i = enemies.length - 1; i >= 0; i--){
    const enemy = enemies[i];
    if(enemy.x === player.x && enemy.y === player.y){
      if(invisActive > 0){
        enemy.brainwashed = true;
        enemy.huntingTarget = null;
      } else if(!enemy.brainwashed){
        game.gameOver = true;
        showGameOver();
        return;
      }
    }
  }
}

function moveEnemiesOneTurn(){
  if(!game || game.gameOver) return;
  
  const {player, enemies, grid, cols, rows, enemyMode, diff, turnCount} = game;
  
  const scatterTurnInterval = Math.floor(diff.scatterInterval / 500);
  const scatterTurnDuration = Math.floor(diff.scatterDuration / 500);
  
  if(enemyMode === 'chase' && turnCount % (scatterTurnInterval + scatterTurnDuration) >= scatterTurnInterval){
    if(game.enemyMode === 'chase'){
      game.enemyMode = 'scatter';
      enemies.forEach(e => {
        if(!e.brainwashed){
          e.scatterTarget = {x: randInt(cols), y: randInt(rows)};
        }
      });
    }
  } else {
    game.enemyMode = 'chase';
  }
  
  for(let i = enemies.length - 1; i >= 0; i--){
    const enemy = enemies[i];
    
    if(enemy.brainwashed){
      if(!enemy.huntingTarget || enemy.huntingTarget.brainwashed){
        let closestEnemy = null;
        let closestDist = Infinity;
        
        for(const otherEnemy of enemies){
          if(otherEnemy === enemy || otherEnemy.brainwashed) continue;
          const d = dist(enemy.x, enemy.y, otherEnemy.x, otherEnemy.y);
          if(d < closestDist){
            closestDist = d;
            closestEnemy = otherEnemy;
          }
        }
        
        enemy.huntingTarget = closestEnemy;
      }
      
      if(enemy.huntingTarget){
        const target = enemy.huntingTarget;
        const possibleMoves = neighbors(grid, cols, rows, enemy.x, enemy.y);
        
        if(possibleMoves.length > 0){
          let best = possibleMoves[0];
          let bestDist = dist(best[0], best[1], target.x, target.y);
          
          for(const [nx,ny] of possibleMoves){
            const d = dist(nx, ny, target.x, target.y);
            if(d < bestDist){
              bestDist = d;
              best = [nx,ny];
            }
          }
          
          enemy.x = best[0];
          enemy.y = best[1];
          
          if(enemy.x === target.x && enemy.y === target.y){
            const targetIdx = enemies.indexOf(target);
            if(targetIdx !== -1) enemies.splice(targetIdx, 1);
            
            const enemyIdx = enemies.indexOf(enemy);
            if(enemyIdx !== -1) enemies.splice(enemyIdx, 1);
            
            continue;
          }
        }
      }
    } else {
      const target = game.enemyMode === 'chase' 
        ? {x: player.x, y: player.y}
        : enemy.scatterTarget;
      
      const possibleMoves = neighbors(grid, cols, rows, enemy.x, enemy.y);
      if(possibleMoves.length === 0) continue;
      
      let best = possibleMoves[0];
      
      if(game.enemyMode === 'chase'){
        const {dist: playerDistMap} = bfsAllPrev(grid, cols, rows, target.x, target.y);
        let bestPathDist = playerDistMap[best[1]][best[0]];
        
        for(const [nx,ny] of possibleMoves){
          const pathDist = playerDistMap[ny][nx];
          if(pathDist < bestPathDist){
            bestPathDist = pathDist;
            best = [nx,ny];
          }
        }
      } else {
        let bestDist = dist(best[0], best[1], target.x, target.y);
        for(const [nx,ny] of possibleMoves){
          const d = dist(nx, ny, target.x, target.y);
          if(d < bestDist){
            bestDist = d;
            best = [nx,ny];
          }
        }
      }
      
      enemy.x = best[0];
      enemy.y = best[1];
      
      if(game.invisActive === 0 && enemy.x === player.x && enemy.y === player.y){
        game.gameOver = true;
        showGameOver();
        return;
      }
    }
  }
  
  updateStatus();
}

function useInvisibility(){
  if(!game || game.gameOver) return;
  if(game.invisRemaining > 0 && game.invisActive === 0){
    game.invisRemaining--;
    game.invisActive = 10;
    game.totalInvisUsed++;
    updateStatus();
    draw();
  }
}

function showGameOver(){
  const modal = document.createElement('div');
  modal.className = 'game-over';
  
  if(game.won){
    const remaining = game.stepsLeft;
    const total = game.maxSteps;
    const ratio = remaining / total;
    
    let rank = 'B';
    if(ratio >= 0.3) rank = 'S';
    else if(ratio >= 0.15) rank = 'A';
    
    modal.innerHTML = `
      <div>ğŸ‰ ã‚¯ãƒªã‚¢! ğŸ‰</div>
      <div class="rank ${rank}">${rank}</div>
      <div>æ®‹ã‚Šæ­©æ•°: ${remaining} / ${total}</div>
      <button onclick="location.reload()">ã‚‚ã†ä¸€åº¦</button>
    `;
  } else {
    modal.innerHTML = `
      <div>ğŸ’€ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ ğŸ’€</div>
      <div>${game.stepsLeft <= 0 ? 'æ­©æ•°åˆ‡ã‚Œ' : 'æ•µã«æ•ã¾ã£ãŸ'}</div>
      <button onclick="location.reload()">ãƒªãƒˆãƒ©ã‚¤</button>
    `;
  }
  
  document.body.appendChild(modal);
}

/* æç”» - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸­å¿ƒã®ã‚«ãƒ¡ãƒ© */
function draw(){
  if(!game) return;
  
  ctx.clearRect(0,0,canvas.width,canvas.height);
  
  const {grid, cols, rows, player, goals, enemies, healItems, invisItems} = game;
  
  // ã‚»ãƒ«ã‚µã‚¤ã‚ºã‚’è¨ˆç®—ï¼ˆå®Ÿéš›ã®æç”»ã‚µã‚¤ã‚ºã‚’ä½¿ç”¨ï¼‰
  const displayWidth = canvas.clientWidth || canvas.width;
  const displayHeight = canvas.clientHeight || canvas.height;
  const visibleRows = Math.min(15, rows); // ç”»é¢ã«è¡¨ç¤ºã™ã‚‹è¡Œæ•°
  const s = Math.floor(displayHeight / visibleRows);
  
  // ã‚«ãƒ¡ãƒ©ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä¸­å¿ƒã«ï¼‰
  const camX = player.x * s - displayWidth / 2 + s / 2;
  const camY = player.y * s - displayHeight / 2 + s / 2;
  
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,displayWidth,displayHeight);
  
  // å£
  ctx.strokeStyle = '#333';
  ctx.lineWidth = Math.max(2, Math.floor(s*0.12));
  ctx.lineCap = 'square';
  
  // è¡¨ç¤ºç¯„å›²ã‚’è¨ˆç®—
  const startX = Math.max(0, Math.floor(camX / s) - 1);
  const endX = Math.min(cols, Math.ceil((camX + displayWidth) / s) + 1);
  const startY = Math.max(0, Math.floor(camY / s) - 1);
  const endY = Math.min(rows, Math.ceil((camY + displayHeight) / s) + 1);
  
  ctx.beginPath();
  for(let y=startY; y<endY; y++){
    for(let x=startX; x<endX; x++){
      const c = grid[y][x];
      const x0 = x * s - camX;
      const y0 = y * s - camY;
      const x1 = x0 + s;
      const y1 = y0 + s;
      
      if(c.w.N){ ctx.moveTo(x0,y0); ctx.lineTo(x1,y0); }
      if(c.w.E){ ctx.moveTo(x1,y0); ctx.lineTo(x1,y1); }
      if(c.w.S){ ctx.moveTo(x0,y1); ctx.lineTo(x1,y1); }
      if(c.w.W){ ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); }
    }
  }
  ctx.stroke();
  
  // ã‚´ãƒ¼ãƒ«
  for(const [gx,gy] of goals){
    const cx = gx * s - camX + s / 2;
    const cy = gy * s - camY + s / 2;
    if(cx < -s || cx > displayWidth + s || cy < -s || cy > displayHeight + s) continue;
    
    const r = s*0.35;
    
    ctx.fillStyle = '#4CAF50';
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.floor(s*0.5)}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('G', cx, cy);
  }
  
  // å›å¾©ã‚¢ã‚¤ãƒ†ãƒ 
  for(const [hx,hy] of healItems){
    const cx = hx * s - camX + s / 2;
    const cy = hy * s - camY + s / 2;
    if(cx < -s || cx > displayWidth + s || cy < -s || cy > displayHeight + s) continue;
    
    ctx.font = `${Math.floor(s*0.7)}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ğŸ’Š', cx, cy);
  }
  
  // é€æ˜åŒ–ã‚¢ã‚¤ãƒ†ãƒ 
  for(const [ix,iy] of invisItems){
    const cx = ix * s - camX + s / 2;
    const cy = iy * s - camY + s / 2;
    if(cx < -s || cx > displayWidth + s || cy < -s || cy > displayHeight + s) continue;
    
    ctx.font = `${Math.floor(s*0.7)}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ğŸ‘»', cx, cy);
  }
  
  // æ•µ
  for(const enemy of enemies){
    const cx = enemy.x * s - camX + s / 2;
    const cy = enemy.y * s - camY + s / 2;
    if(cx < -s || cx > displayWidth + s || cy < -s || cy > displayHeight + s) continue;
    
    const r = s*0.35;
    
    if(enemy.brainwashed){
      ctx.fillStyle = '#2196F3';
    } else {
      ctx.fillStyle = game.enemyMode === 'chase' ? '#f44336' : '#FF9800';
    }
    
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.floor(s*0.55)}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    let enemyChar = 'å…µ';
    if(enemy.brainwashed && game.invisActive > 0){
      enemyChar = 'ç”·';
    }
    
    ctx.fillText(enemyChar, cx, cy);
  }
  
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆå¸¸ã«ä¸­å¤®ï¼‰
  const px = displayWidth / 2;
  const py = displayHeight / 2;
  const pr = s*0.38;
  
  if(game.invisActive > 0){
    ctx.globalAlpha = 0.5;
  }
  
  ctx.fillStyle = '#2196F3';
  ctx.beginPath();
  ctx.arc(px,py,pr,0,Math.PI*2);
  ctx.fill();
  
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.floor(s*0.55)}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  let playerChar = 'äºº';
  if(game.totalInvisUsed >= 2){
    playerChar = 'å¦–';
  } else if(game.invisActive > 0){
    playerChar = 'å¥³';
  }
  
  ctx.fillText(playerChar, px, py);
}

/* ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ */
document.getElementById('gen').addEventListener('click', initGame);

// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
document.addEventListener('keydown', e => {
  if(!game || game.gameOver) return;
  
  const key = e.key.toLowerCase();
  
  if(key === 'arrowup' || key === 'w'){
    e.preventDefault();
    movePlayer(0,-1);
  } else if(key === 'arrowdown' || key === 's'){
    e.preventDefault();
    movePlayer(0,1);
  } else if(key === 'arrowleft' || key === 'a'){
    e.preventDefault();
    movePlayer(-1,0);
  } else if(key === 'arrowright' || key === 'd'){
    e.preventDefault();
    movePlayer(1,0);
  } else if(key === ' '){
    e.preventDefault();
    useInvisibility();
  }
});

// ã‚¿ãƒƒãƒæ“ä½œ
document.querySelectorAll('.dpad-btn').forEach(btn => {
  btn.addEventListener('touchstart', e => {
    e.preventDefault();
    const dir = btn.dataset.dir;
    if(dir === 'up') movePlayer(0,-1);
    else if(dir === 'down') movePlayer(0,1);
    else if(dir === 'left') movePlayer(-1,0);
    else if(dir === 'right') movePlayer(1,0);
  });
  
  btn.addEventListener('click', e => {
    e.preventDefault();
    const dir = btn.dataset.dir;
    if(dir === 'up') movePlayer(0,-1);
    else if(dir === 'down') movePlayer(0,1);
    else if(dir === 'left') movePlayer(-1,0);
    else if(dir === 'right') movePlayer(1,0);
  });
});

document.getElementById('invisBtn').addEventListener('touchstart', e => {
  e.preventDefault();
  useInvisibility();
});

document.getElementById('invisBtn').addEventListener('click', e => {
  e.preventDefault();
  useInvisibility();
});

// åˆæœŸç”Ÿæˆ
initGame();
</script>
</body>
</html>
