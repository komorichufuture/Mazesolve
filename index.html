<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>è¿·è·¯ã‚²ãƒ¼ãƒ  - ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ</title>
<style>
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#1a1a2e;color:#eee;font-family:system-ui,-apple-system,sans-serif}
  
  .app{display:flex;flex-direction:column;height:100dvh;height:100vh;max-height:-webkit-fill-available}
  
  /* === ä¸Šéƒ¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ === */
  .top-area{flex-shrink:0;padding:6px 8px;background:#16213e}
  
  .settings-bar{display:flex;gap:4px;flex-wrap:wrap;align-items:center;justify-content:center;margin-bottom:6px}
  .settings-bar button,.settings-bar select,.settings-bar label{
    font-size:12px;padding:5px 8px;border:1px solid rgba(255,255,255,.2);
    background:rgba(255,255,255,.08);color:#eee;border-radius:6px;white-space:nowrap
  }
  .settings-bar button.primary{background:#4CAF50;border-color:#4CAF50;color:#fff;font-weight:700}
  .settings-bar button:active,.settings-bar select:active{background:rgba(255,255,255,.2)}
  .settings-bar label{display:flex;gap:3px;align-items:center}
  .settings-bar input[type="number"]{width:44px;padding:2px 4px;font-size:12px;background:rgba(255,255,255,.1);color:#eee;border:1px solid rgba(255,255,255,.2);border-radius:4px;text-align:center}
  .settings-bar select{padding:4px 6px}
  
  .status-bar{display:flex;gap:6px;flex-wrap:wrap;align-items:center;justify-content:center;font-size:12px;padding:4px 0}
  .status-item{display:flex;gap:3px;align-items:center;background:rgba(255,255,255,.06);padding:3px 7px;border-radius:5px}
  .status-label{color:#aaa;font-weight:400}
  .status-value{color:#fff;font-weight:700}
  
  /* === æ“ä½œç›¤ === */
  .controls-area{flex-shrink:0;display:flex;align-items:center;justify-content:center;gap:12px;padding:6px 8px;background:#0f3460}
  
  .dpad{display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:3px;width:140px;height:140px}
  .dpad-btn{
    display:flex;align-items:center;justify-content:center;
    border:none;border-radius:10px;font-size:24px;cursor:pointer;
    background:rgba(255,255,255,.12);color:#fff;
    transition:background 0.1s;
    touch-action:manipulation;user-select:none;-webkit-user-select:none
  }
  .dpad-btn:active,.dpad-btn.pressed{background:rgba(255,255,255,.35);transform:scale(0.95)}
  .dpad-center{background:rgba(255,255,255,.04);border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:11px;color:#888}
  .dpad-empty{pointer-events:none}
  
  .side-btns{display:flex;flex-direction:column;gap:6px}
  .action-btn{
    width:64px;height:64px;border:none;border-radius:12px;font-size:13px;font-weight:700;
    cursor:pointer;touch-action:manipulation;user-select:none;-webkit-user-select:none;
    display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px;line-height:1.2
  }
  .btn-invis{background:#9C27B0;color:#fff}
  .btn-invis:active{background:#7B1FA2}
  .btn-invis:disabled{background:#555;color:#999}
  
  /* === ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¨ãƒªã‚¢ === */
  .canvas-area{flex:1;display:flex;align-items:center;justify-content:center;overflow:hidden;padding:4px;min-height:0}
  canvas{border-radius:6px;touch-action:none;background:#fff;max-width:100%;max-height:100%}
  
  /* === ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« === */
  .game-over{
    position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
    background:rgba(0,0,0,0.95);color:#fff;padding:30px 40px;border-radius:16px;
    text-align:center;font-size:20px;z-index:1000;box-shadow:0 8px 32px rgba(0,0,0,0.5);
    max-width:90vw
  }
  .game-over .rank{font-size:64px;font-weight:bold;margin:16px 0;text-shadow:0 0 20px rgba(255,255,255,0.5)}
  .game-over .rank.S{color:#FFD700}
  .game-over .rank.A{color:#C0C0C0}
  .game-over .rank.B{color:#CD7F32}
  .game-over button{margin-top:16px;font-size:16px;padding:10px 24px;border:none;border-radius:8px;background:#4CAF50;color:#fff;font-weight:700;cursor:pointer}
  .game-over button:active{background:#45a049}
  
  /* === PCå‘ã‘å¾®èª¿æ•´ === */
  @media(min-width:700px){
    .top-area{padding:8px 16px}
    .settings-bar button,.settings-bar select,.settings-bar label{font-size:13px;padding:6px 12px}
    .status-bar{font-size:14px}
    .controls-area{padding:8px 16px}
    .dpad{width:160px;height:160px}
    .dpad-btn{font-size:28px}
    .action-btn{width:72px;height:72px;font-size:14px}
  }
  
  /* æ¨ªå‘ãã‚¹ãƒãƒ› */
  @media(max-height:500px) and (orientation:landscape){
    .app{flex-direction:row}
    .top-area{display:none}
    .controls-area{flex-direction:column;width:auto;padding:4px}
    .dpad{width:120px;height:120px}
    .dpad-btn{font-size:20px}
    .action-btn{width:56px;height:56px;font-size:11px}
    .canvas-area{padding:2px}
  }
</style>
</head>
<body>
<div class="app">
  <!-- è¨­å®šãƒãƒ¼ -->
  <div class="top-area">
    <div class="settings-bar">
      <button id="gen" class="primary">â–¶ æ–°ã‚²ãƒ¼ãƒ </button>
      <label>åˆ—<input id="cols" type="number" min="21" max="101" step="2" value="21"></label>
      <label>è¡Œ<input id="rows" type="number" min="21" max="101" step="2" value="21"></label>
      <select id="difficulty">
        <option value="easy">ç°¡å˜</option>
        <option value="normal" selected>æ™®é€š</option>
        <option value="hard">é›£ã—ã„</option>
      </select>
    </div>
    <div class="status-bar">
      <div class="status-item"><span class="status-label">æ­©æ•°</span><span class="status-value" id="stepsLeft">-</span></div>
      <div class="status-item"><span class="status-label">é€æ˜</span><span class="status-value" id="invisCount">-</span></div>
      <div class="status-item"><span class="status-label">æ•µ</span><span class="status-value" id="enemyMode">-</span></div>
      <div class="status-item"><span class="status-label">æ´—è„³</span><span class="status-value" id="brainwashedCount">0</span></div>
    </div>
  </div>
  
  <!-- æ“ä½œç›¤ -->
  <div class="controls-area">
    <div class="dpad">
      <div class="dpad-empty"></div>
      <button class="dpad-btn" data-dir="up">â–²</button>
      <div class="dpad-empty"></div>
      <button class="dpad-btn" data-dir="left">â—€</button>
      <div class="dpad-center">â—</div>
      <button class="dpad-btn" data-dir="right">â–¶</button>
      <div class="dpad-empty"></div>
      <button class="dpad-btn" data-dir="down">â–¼</button>
      <div class="dpad-empty"></div>
    </div>
    <div class="side-btns">
      <button class="action-btn btn-invis" id="invisBtn">ğŸ‘»<span style="font-size:10px">é€æ˜åŒ–</span></button>
    </div>
  </div>
  
  <!-- ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
  <div class="canvas-area">
    <canvas id="c"></canvas>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

/* === ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒªã‚µã‚¤ã‚º === */
function resizeCanvas(){
  const area = document.querySelector('.canvas-area');
  const w = area.clientWidth - 8;
  const h = area.clientHeight - 8;
  
  if(game){
    const aspect = game.cols / game.rows;
    if(w / h > aspect){
      canvas.height = Math.min(h, 2000);
      canvas.width = Math.floor(canvas.height * aspect);
    } else {
      canvas.width = Math.min(w, 2000);
      canvas.height = Math.floor(canvas.width / aspect);
    }
  } else {
    canvas.width = Math.min(w, 800);
    canvas.height = Math.min(h, 600);
  }
  draw();
}

window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', ()=> setTimeout(resizeCanvas, 200));

/* === ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå¤‰æ›´ãªã—ï¼‰ === */
const DIRS = [
  {k:'N', dx:0, dy:-1, opp:'S'},
  {k:'E', dx:1, dy:0,  opp:'W'},
  {k:'S', dx:0, dy:1,  opp:'N'},
  {k:'W', dx:-1,dy:0,  opp:'E'},
];

const DIFFICULTY = {
  easy: {stepMult: 1.8, enemyCount: 4, scatterInterval: 8000, scatterDuration: 3000},
  normal: {stepMult: 1.4, enemyCount: 6, scatterInterval: 10000, scatterDuration: 2500},
  hard: {stepMult: 1.2, enemyCount: 9, scatterInterval: 12000, scatterDuration: 2000}
};

function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
function oddize(n){ n = Math.round(n); return (n%2===0)? n+1 : n; }
function randInt(n){ return Math.floor(Math.random()*n); }
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = randInt(i+1);
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function inBounds(x,y,cols,rows){ return x>=0 && y>=0 && x<cols && y<rows; }
function dist(x1,y1,x2,y2){ return Math.abs(x1-x2) + Math.abs(y1-y2); }

function makeGrid(cols, rows){
  return Array.from({length:rows}, (_,y)=>
    Array.from({length:cols}, (_,x)=>({
      x,y,
      v:false,
      w:{N:true,E:true,S:true,W:true}
    }))
  );
}

function carveMazeDFS(grid, cols, rows, sx, sy){
  const st = [];
  const start = grid[sy][sx];
  start.v = true;
  st.push(start);

  while(st.length){
    const cur = st[st.length-1];
    const dirs = shuffle(DIRS.slice());
    let carved = false;

    for(const d of dirs){
      const nx = cur.x + d.dx, ny = cur.y + d.dy;
      if(!inBounds(nx,ny,cols,rows)) continue;
      const nb = grid[ny][nx];
      if(nb.v) continue;

      cur.w[d.k] = false;
      nb.w[d.opp] = false;
      nb.v = true;
      st.push(nb);
      carved = true;
      break;
    }
    if(!carved) st.pop();
  }
}

function addLoops(grid, cols, rows, breaks){
  let tries = breaks * 4;
  while(breaks > 0 && tries-- > 0){
    const x = randInt(cols);
    const y = randInt(rows);
    const cell = grid[y][x];
    const d = DIRS[randInt(4)];
    const nx = x + d.dx, ny = y + d.dy;
    if(!inBounds(nx,ny,cols,rows)) continue;
    if(cell.w[d.k] === false) continue;

    cell.w[d.k] = false;
    grid[ny][nx].w[d.opp] = false;
    breaks--;
  }
}

function pickGoalsOnBoundary(cols, rows, count, startX, startY){
  const cand = [];
  for(let x=0;x<cols;x++){
    cand.push([x,0],[x,rows-1]);
  }
  for(let y=1;y<rows-1;y++){
    cand.push([0,y],[cols-1,y]);
  }
  const uniq = new Map();
  for(const [x,y] of cand){
    if(x===startX && y===startY) continue;
    uniq.set(`${x},${y}`,[x,y]);
  }
  const list = Array.from(uniq.values());
  shuffle(list);
  return list.slice(0, clamp(count,1,list.length));
}

function neighbors(grid, cols, rows, x, y){
  const c = grid[y][x];
  const out = [];
  for(const d of DIRS){
    const nx = x + d.dx, ny = y + d.dy;
    if(!inBounds(nx,ny,cols,rows)) continue;
    if(c.w[d.k] === false){
      out.push([nx,ny]);
    }
  }
  return out;
}

function bfsAllPrev(grid, cols, rows, sx, sy){
  const prev = Array.from({length:rows}, ()=>Array(cols).fill(null));
  const distMap = Array.from({length:rows}, ()=>Array(cols).fill(Infinity));
  const qx = new Int32Array(cols*rows);
  const qy = new Int32Array(cols*rows);
  let head=0, tail=0;

  distMap[sy][sx] = 0;
  qx[tail]=sx; qy[tail]=sy; tail++;

  while(head<tail){
    const x = qx[head], y = qy[head]; head++;
    const d0 = distMap[y][x];
    for(const [nx,ny] of neighbors(grid,cols,rows,x,y)){
      if(distMap[ny][nx] !== Infinity) continue;
      distMap[ny][nx] = d0 + 1;
      prev[ny][nx] = [x,y];
      qx[tail]=nx; qy[tail]=ny; tail++;
    }
  }
  return {prev, dist:distMap};
}

function reconstructPath(prev, sx, sy, gx, gy){
  if(prev[gy][gx] === null && !(sx===gx && sy===gy)) return null;
  const path = [];
  let x=gx, y=gy;
  path.push([x,y]);
  while(!(x===sx && y===sy)){
    const p = prev[y][x];
    if(!p) return null;
    x=p[0]; y=p[1];
    path.push([x,y]);
  }
  path.reverse();
  return path;
}

function placeItemsByDistance(distMap, cols, rows, minPct, maxPct, maxDist, count){
  const candidates = [];
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const d = distMap[y][x];
      if(d === Infinity || d === 0) continue;
      const pct = d / maxDist;
      if(pct >= minPct && pct <= maxPct){
        candidates.push([x,y]);
      }
    }
  }
  shuffle(candidates);
  return candidates.slice(0, Math.min(count, candidates.length));
}

function placeEnemiesOnGoalPaths(grid, cols, rows, start, goals, distMap, totalCount){
  const [sx, sy] = start;
  const allPathCells = new Set();
  const pathsByGoal = [];
  
  const {prev} = bfsAllPrev(grid, cols, rows, sx, sy);
  
  for(const [gx, gy] of goals){
    const path = reconstructPath(prev, sx, sy, gx, gy);
    if(!path) continue;
    
    const pathCells = [];
    for(let i=1; i<path.length-1; i++){
      const [px, py] = path[i];
      const key = `${px},${py}`;
      allPathCells.add(key);
      pathCells.push({x:px, y:py, dist: distMap[py][px]});
    }
    
    if(pathCells.length > 0){
      pathsByGoal.push({goal: [gx,gy], cells: pathCells});
    }
  }
  
  const selected = [];
  const used = new Set();
  
  const enemiesPerPath = Math.ceil(totalCount / Math.max(1, pathsByGoal.length));
  
  for(const {cells} of pathsByGoal){
    cells.sort((a,b) => b.dist - a.dist);
    
    let placed = 0;
    for(const {x, y, dist: d} of cells){
      if(placed >= enemiesPerPath) break;
      if(selected.length >= totalCount) break;
      
      const key = `${x},${y}`;
      if(used.has(key)) continue;
      
      const maxPathDist = cells[0].dist;
      const pct = d / maxPathDist;
      if(pct < 0.3 || pct > 0.95) continue;
      
      let tooClose = false;
      for(const [ex, ey] of selected){
        if(dist(x, y, ex, ey) < 4){
          tooClose = true;
          break;
        }
      }
      if(tooClose) continue;
      
      selected.push([x, y]);
      used.add(key);
      placed++;
    }
  }
  
  if(selected.length < totalCount){
    const candidates = [];
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        const d = distMap[y][x];
        if(d === Infinity || d < 5) continue;
        const key = `${x},${y}`;
        if(used.has(key)) continue;
        candidates.push({x, y, dist: d});
      }
    }
    
    candidates.sort((a,b) => b.dist - a.dist);
    
    for(const {x, y} of candidates){
      if(selected.length >= totalCount) break;
      
      let tooClose = false;
      for(const [ex, ey] of selected){
        if(dist(x, y, ex, ey) < 4){
          tooClose = true;
          break;
        }
      }
      if(tooClose) continue;
      
      selected.push([x, y]);
      used.add(`${x},${y}`);
    }
  }
  
  return selected;
}

/* ===== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ===== */
let game = null;

function initGame(){
  // æ—¢å­˜ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’å‰Šé™¤
  document.querySelectorAll('.game-over').forEach(e=>e.remove());
  
  let cols = oddize(parseInt(document.getElementById('cols').value,10));
  let rows = oddize(parseInt(document.getElementById('rows').value,10));
  cols = clamp(cols, 21, 101);
  rows = clamp(rows, 21, 101);
  
  const diffKey = document.getElementById('difficulty').value;
  const diff = DIFFICULTY[diffKey];
  
  const grid = makeGrid(cols, rows);
  const sx = Math.floor(cols/2);
  const sy = Math.floor(rows/2);
  
  carveMazeDFS(grid, cols, rows, sx, sy);
  addLoops(grid, cols, rows, Math.floor(cols * rows * 0.02));
  
  const goals = pickGoalsOnBoundary(cols, rows, 3, sx, sy);
  
  const {prev, dist:distMap} = bfsAllPrev(grid, cols, rows, sx, sy);
  
  let minDist = Infinity;
  for(const [gx,gy] of goals){
    const d = distMap[gy][gx];
    if(d < minDist) minDist = d;
  }
  
  const maxSteps = Math.ceil(minDist * diff.stepMult);
  
  const healItems = placeItemsByDistance(distMap, cols, rows, 0.60, 0.75, minDist, 2);
  const invisItems = placeItemsByDistance(distMap, cols, rows, 0.35, 0.45, minDist, 1)
    .concat(placeItemsByDistance(distMap, cols, rows, 0.45, 0.55, minDist, 1));
  
  const enemyPositions = placeEnemiesOnGoalPaths(grid, cols, rows, [sx, sy], goals, distMap, diff.enemyCount);
  const enemies = enemyPositions.map(([x,y])=>({
    x, y,
    scatterTarget: {x: randInt(cols), y: randInt(rows)},
    brainwashed: false,
    huntingTarget: null
  }));
  
  game = {
    grid, cols, rows,
    player: {x: sx, y: sy, invisUsedCount: 0},
    goals,
    enemies,
    healItems,
    invisItems,
    maxSteps,
    stepsLeft: maxSteps,
    invisRemaining: 2,
    totalInvisUsed: 0,
    invisActive: 0,
    gameOver: false,
    won: false,
    enemyMode: 'chase',
    modeTimer: 0,
    turnCount: 0,
    diff
  };
  
  resizeCanvas();
  updateStatus();
  draw();
}

function updateStatus(){
  if(!game) return;
  document.getElementById('stepsLeft').textContent = game.stepsLeft;
  document.getElementById('invisCount').textContent = `${game.invisRemaining}(${game.invisActive})`;
  document.getElementById('enemyMode').textContent = game.enemyMode === 'chase' ? 'è¿½è·¡' : 'æ•£é–‹';
  
  const brainwashedCount = game.enemies.filter(e => e.brainwashed).length;
  document.getElementById('brainwashedCount').textContent = brainwashedCount;
  
  // é€æ˜åŒ–ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
  const btn = document.getElementById('invisBtn');
  btn.disabled = game.invisRemaining <= 0 || game.invisActive > 0;
}

function movePlayer(dx, dy){
  if(!game || game.gameOver) return;
  
  const {player, grid, cols, rows} = game;
  const cell = grid[player.y][player.x];
  
  let dirKey = null;
  if(dx===0 && dy===-1) dirKey = 'N';
  else if(dx===1 && dy===0) dirKey = 'E';
  else if(dx===0 && dy===1) dirKey = 'S';
  else if(dx===-1 && dy===0) dirKey = 'W';
  
  if(!dirKey || cell.w[dirKey]) return;
  
  const nx = player.x + dx;
  const ny = player.y + dy;
  if(!inBounds(nx,ny,cols,rows)) return;
  
  player.x = nx;
  player.y = ny;
  game.stepsLeft--;
  game.turnCount++;
  
  // è¡çªåˆ¤å®šã‚’å…ˆã«è¡Œã„ã€ãã®å¾Œã«é€æ˜ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’æ¸›ã‚‰ã™
  checkEnemyCollisions();
  
  if(game.gameOver) return;
  
  if(game.invisActive > 0) game.invisActive--;
  
  for(const [gx,gy] of game.goals){
    if(player.x === gx && player.y === gy){
      game.won = true;
      game.gameOver = true;
      showGameOver();
      return;
    }
  }
  
  for(let i=game.healItems.length-1; i>=0; i--){
    const [hx,hy] = game.healItems[i];
    if(player.x === hx && player.y === hy){
      game.stepsLeft += 20;
      game.healItems.splice(i,1);
    }
  }
  
  for(let i=game.invisItems.length-1; i>=0; i--){
    const [ix,iy] = game.invisItems[i];
    if(player.x === ix && player.y === iy){
      game.invisRemaining++;
      game.invisItems.splice(i,1);
    }
  }
  
  moveEnemiesOneTurn();
  
  if(game.stepsLeft <= 0){
    game.gameOver = true;
    showGameOver();
    return;
  }
  
  updateStatus();
  draw();
}

function checkEnemyCollisions(){
  const {player, enemies} = game;
  const invisActive = game.invisActive;
  
  for(let i = enemies.length - 1; i >= 0; i--){
    const enemy = enemies[i];
    if(enemy.x === player.x && enemy.y === player.y){
      if(invisActive > 0){
        // é€æ˜åŒ–ä¸­ â†’ æ•µã‚’æ´—è„³
        enemy.brainwashed = true;
        enemy.huntingTarget = null;
        // æ´—è„³ã—ãŸæ•µã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨é‡ãªã‚‰ãªã„ã‚ˆã†ã«éš£æ¥ã‚»ãƒ«ã¸é€€é¿
        const adj = neighbors(game.grid, game.cols, game.rows, enemy.x, enemy.y);
        if(adj.length > 0){
          let best = adj[0];
          let bestD = dist(best[0], best[1], player.x, player.y);
          for(const [ax,ay] of adj){
            const d = dist(ax, ay, player.x, player.y);
            if(d > bestD){ bestD = d; best = [ax,ay]; }
          }
          enemy.x = best[0];
          enemy.y = best[1];
        }
      } else if(!enemy.brainwashed){
        game.gameOver = true;
        showGameOver();
        return;
      }
    }
  }
}

function moveEnemiesOneTurn(){
  if(!game || game.gameOver) return;
  
  const {player, enemies, grid, cols, rows, enemyMode, diff, turnCount} = game;
  
  const scatterTurnInterval = Math.floor(diff.scatterInterval / 500);
  const scatterTurnDuration = Math.floor(diff.scatterDuration / 500);
  
  if(enemyMode === 'chase' && turnCount % (scatterTurnInterval + scatterTurnDuration) >= scatterTurnInterval){
    if(game.enemyMode === 'chase'){
      game.enemyMode = 'scatter';
      enemies.forEach(e => {
        if(!e.brainwashed){
          e.scatterTarget = {x: randInt(cols), y: randInt(rows)};
        }
      });
    }
  } else {
    game.enemyMode = 'chase';
  }
  
  for(let i = enemies.length - 1; i >= 0; i--){
    const enemy = enemies[i];
    
    if(enemy.brainwashed){
      if(!enemy.huntingTarget || enemy.huntingTarget.brainwashed){
        let closestEnemy = null;
        let closestDist = Infinity;
        
        for(const otherEnemy of enemies){
          if(otherEnemy === enemy || otherEnemy.brainwashed) continue;
          const d = dist(enemy.x, enemy.y, otherEnemy.x, otherEnemy.y);
          if(d < closestDist){
            closestDist = d;
            closestEnemy = otherEnemy;
          }
        }
        
        enemy.huntingTarget = closestEnemy;
      }
      
      if(enemy.huntingTarget){
        const target = enemy.huntingTarget;
        const possibleMoves = neighbors(grid, cols, rows, enemy.x, enemy.y);
        
        if(possibleMoves.length > 0){
          let best = possibleMoves[0];
          let bestDist = dist(best[0], best[1], target.x, target.y);
          
          for(const [nx,ny] of possibleMoves){
            const d = dist(nx, ny, target.x, target.y);
            if(d < bestDist){
              bestDist = d;
              best = [nx,ny];
            }
          }
          
          enemy.x = best[0];
          enemy.y = best[1];
          
          if(enemy.x === target.x && enemy.y === target.y){
            const targetIdx = enemies.indexOf(target);
            if(targetIdx !== -1) enemies.splice(targetIdx, 1);
            
            const enemyIdx = enemies.indexOf(enemy);
            if(enemyIdx !== -1) enemies.splice(enemyIdx, 1);
            
            continue;
          }
        }
      }
    } else {
      const target = game.enemyMode === 'chase' 
        ? {x: player.x, y: player.y}
        : enemy.scatterTarget;
      
      const possibleMoves = neighbors(grid, cols, rows, enemy.x, enemy.y);
      if(possibleMoves.length === 0) continue;
      
      let best = possibleMoves[0];
      
      if(game.enemyMode === 'chase'){
        const {dist: playerDistMap} = bfsAllPrev(grid, cols, rows, target.x, target.y);
        let bestPathDist = playerDistMap[best[1]][best[0]];
        
        for(const [nx,ny] of possibleMoves){
          const pathDist = playerDistMap[ny][nx];
          if(pathDist < bestPathDist){
            bestPathDist = pathDist;
            best = [nx,ny];
          }
        }
      } else {
        let bestDist = dist(best[0], best[1], target.x, target.y);
        for(const [nx,ny] of possibleMoves){
          const d = dist(nx, ny, target.x, target.y);
          if(d < bestDist){
            bestDist = d;
            best = [nx,ny];
          }
        }
      }
      
      enemy.x = best[0];
      enemy.y = best[1];
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çªåˆ¤å®š
      if(enemy.x === player.x && enemy.y === player.y){
        if(game.invisActive > 0){
          // é€æ˜åŒ–ä¸­ â†’ æ•µã‚’æ´—è„³ã—ã¦é€€é¿
          enemy.brainwashed = true;
          enemy.huntingTarget = null;
          const adj = neighbors(grid, cols, rows, enemy.x, enemy.y);
          if(adj.length > 0){
            let b = adj[0];
            let bd = dist(b[0], b[1], player.x, player.y);
            for(const [ax,ay] of adj){
              const dd = dist(ax, ay, player.x, player.y);
              if(dd > bd){ bd = dd; b = [ax,ay]; }
            }
            enemy.x = b[0];
            enemy.y = b[1];
          }
        } else {
          game.gameOver = true;
          showGameOver();
          return;
        }
      }
    }
  }
  
  updateStatus();
}

function useInvisibility(){
  if(!game || game.gameOver) return;
  if(game.invisRemaining > 0 && game.invisActive === 0){
    game.invisRemaining--;
    game.invisActive = 10;
    game.totalInvisUsed++;
    updateStatus();
    draw();
  }
}

function showGameOver(){
  const modal = document.createElement('div');
  modal.className = 'game-over';
  
  if(game.won){
    const remaining = game.stepsLeft;
    const total = game.maxSteps;
    const ratio = remaining / total;
    
    let rank = 'B';
    if(ratio >= 0.3) rank = 'S';
    else if(ratio >= 0.15) rank = 'A';
    
    modal.innerHTML = `
      <div>ğŸ‰ ã‚¯ãƒªã‚¢! ğŸ‰</div>
      <div class="rank ${rank}">${rank}</div>
      <div>æ®‹ã‚Šæ­©æ•°: ${remaining} / ${total}</div>
      <button onclick="document.querySelectorAll('.game-over').forEach(e=>e.remove());initGame()">ã‚‚ã†ä¸€åº¦</button>
    `;
  } else {
    modal.innerHTML = `
      <div>ğŸ’€ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ ğŸ’€</div>
      <div>${game.stepsLeft <= 0 ? 'æ­©æ•°åˆ‡ã‚Œ' : 'æ•µã«æ•ã¾ã£ãŸ'}</div>
      <button onclick="document.querySelectorAll('.game-over').forEach(e=>e.remove());initGame()">ãƒªãƒˆãƒ©ã‚¤</button>
    `;
  }
  
  document.body.appendChild(modal);
}

/* ===== æç”» ===== */
function draw(){
  if(!game) return;
  
  ctx.clearRect(0,0,canvas.width,canvas.height);
  
  const {grid, cols, rows, player, goals, enemies, healItems, invisItems} = game;
  
  const pad = 8;
  const cellW = (canvas.width - pad*2) / cols;
  const cellH = (canvas.height - pad*2) / rows;
  const s = Math.min(cellW, cellH);
  const offX = (canvas.width  - cols*s)/2;
  const offY = (canvas.height - rows*s)/2;
  
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  
  // å£
  ctx.strokeStyle = '#333';
  ctx.lineWidth = Math.max(1, Math.floor(s*0.1));
  ctx.lineCap = 'square';
  
  ctx.beginPath();
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const c = grid[y][x];
      const x0 = offX + x*s;
      const y0 = offY + y*s;
      const x1 = x0 + s;
      const y1 = y0 + s;
      
      if(c.w.N){ ctx.moveTo(x0,y0); ctx.lineTo(x1,y0); }
      if(c.w.E){ ctx.moveTo(x1,y0); ctx.lineTo(x1,y1); }
      if(c.w.S){ ctx.moveTo(x0,y1); ctx.lineTo(x1,y1); }
      if(c.w.W){ ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); }
    }
  }
  ctx.stroke();
  
  // ã‚´ãƒ¼ãƒ«
  for(const [gx,gy] of goals){
    const cx = offX + (gx+0.5)*s;
    const cy = offY + (gy+0.5)*s;
    const r = s*0.35;
    
    ctx.fillStyle = '#4CAF50';
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.max(8, Math.floor(s*0.4))}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('G', cx, cy);
  }
  
  // å›å¾©ã‚¢ã‚¤ãƒ†ãƒ 
  for(const [hx,hy] of healItems){
    const cx = offX + (hx+0.5)*s;
    const cy = offY + (hy+0.5)*s;
    ctx.font = `${Math.max(8, Math.floor(s*0.6))}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ğŸ’Š', cx, cy);
  }
  
  // é€æ˜åŒ–ã‚¢ã‚¤ãƒ†ãƒ 
  for(const [ix,iy] of invisItems){
    const cx = offX + (ix+0.5)*s;
    const cy = offY + (iy+0.5)*s;
    ctx.font = `${Math.max(8, Math.floor(s*0.6))}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ğŸ‘»', cx, cy);
  }
  
  // æ•µ
  for(const enemy of enemies){
    const cx = offX + (enemy.x+0.5)*s;
    const cy = offY + (enemy.y+0.5)*s;
    const r = s*0.32;
    
    if(enemy.brainwashed){
      ctx.fillStyle = '#2196F3';
    } else {
      ctx.fillStyle = game.enemyMode === 'chase' ? '#f44336' : '#FF9800';
    }
    
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.max(6, Math.floor(s*0.5))}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    let enemyChar = 'å…µ';
    if(enemy.brainwashed && game.invisActive > 0){
      enemyChar = 'ç”·';
    } else if(enemy.brainwashed){
      enemyChar = 'å…µ';
    }
    
    ctx.fillText(enemyChar, cx, cy);
  }
  
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
  const px = offX + (player.x+0.5)*s;
  const py = offY + (player.y+0.5)*s;
  const pr = s*0.35;
  
  if(game.invisActive > 0){
    ctx.globalAlpha = 0.4;
  }
  
  ctx.fillStyle = '#2196F3';
  ctx.beginPath();
  ctx.arc(px,py,pr,0,Math.PI*2);
  ctx.fill();
  
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.max(6, Math.floor(s*0.5))}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  let playerChar = 'äºº';
  if(game.totalInvisUsed >= 2){
    playerChar = 'å¦–';
  } else if(game.invisActive > 0){
    playerChar = 'å¥³';
  }
  
  ctx.fillText(playerChar, px, py);
}

/* ===== å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆ ===== */
document.getElementById('gen').addEventListener('click', initGame);

// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰
document.addEventListener('keydown', e => {
  if(!game || game.gameOver) return;
  
  const key = e.key.toLowerCase();
  
  if(key === 'arrowup' || key === 'w'){
    e.preventDefault();
    movePlayer(0,-1);
  } else if(key === 'arrowdown' || key === 's'){
    e.preventDefault();
    movePlayer(0,1);
  } else if(key === 'arrowleft' || key === 'a'){
    e.preventDefault();
    movePlayer(-1,0);
  } else if(key === 'arrowright' || key === 'd'){
    e.preventDefault();
    movePlayer(1,0);
  } else if(key === ' '){
    e.preventDefault();
    useInvisibility();
  }
});

// D-Padã‚¿ãƒƒãƒæ“ä½œï¼ˆé€£ç¶šå…¥åŠ›å¯¾å¿œï¼‰
const dirMap = {up:[0,-1], down:[0,1], left:[-1,0], right:[1,0]};
let repeatTimer = null;
let repeatDir = null;

function startRepeat(dir){
  stopRepeat();
  repeatDir = dir;
  const [dx,dy] = dirMap[dir];
  movePlayer(dx,dy);
  // é•·æŠ¼ã—ã§é€£ç¶šç§»å‹•
  repeatTimer = setTimeout(function tick(){
    if(repeatDir === dir){
      const [dx,dy] = dirMap[dir];
      movePlayer(dx,dy);
      repeatTimer = setTimeout(tick, 120);
    }
  }, 300);
}

function stopRepeat(){
  repeatDir = null;
  if(repeatTimer){
    clearTimeout(repeatTimer);
    repeatTimer = null;
  }
}

document.querySelectorAll('.dpad-btn').forEach(btn => {
  const dir = btn.dataset.dir;
  
  btn.addEventListener('touchstart', e => {
    e.preventDefault();
    btn.classList.add('pressed');
    startRepeat(dir);
  });
  btn.addEventListener('touchend', e => {
    e.preventDefault();
    btn.classList.remove('pressed');
    stopRepeat();
  });
  btn.addEventListener('touchcancel', e => {
    btn.classList.remove('pressed');
    stopRepeat();
  });
  
  // ãƒã‚¦ã‚¹ã§ã‚‚å‹•ä½œ
  btn.addEventListener('mousedown', e => {
    e.preventDefault();
    btn.classList.add('pressed');
    startRepeat(dir);
  });
});

document.addEventListener('mouseup', () => {
  document.querySelectorAll('.dpad-btn.pressed').forEach(b=>b.classList.remove('pressed'));
  stopRepeat();
});

// é€æ˜åŒ–ãƒœã‚¿ãƒ³
document.getElementById('invisBtn').addEventListener('click', useInvisibility);
document.getElementById('invisBtn').addEventListener('touchstart', e => {
  e.preventDefault();
  useInvisibility();
});

// ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šï¼‰
let touchStartX = 0, touchStartY = 0;

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
});

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  if(e.changedTouches.length === 0) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;
  const threshold = 20;
  
  if(Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
  
  if(Math.abs(dx) > Math.abs(dy)){
    movePlayer(dx > 0 ? 1 : -1, 0);
  } else {
    movePlayer(0, dy > 0 ? 1 : -1);
  }
});

// åˆæœŸç”Ÿæˆ
initGame();
</script>
</body>
</html>
